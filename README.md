import unittestimport hashlibimport timeimport jsonimport rsaimport randomfrom p2pnetwork.node import Node class BlockChain(Node): def __init__(self, host='127.0.0.1', port=None): self.blocks = [] self.current_transactions = [] self.blocks = [] self.nodes = [] self.difficulty = 4 #represents the number of zeros that are required to be in the hash if port == None: random.seed() port = random.randint(10000, 20000) super(BlockChain, self).__init__(host, port) self.start() def new_block(self): previous_hash = None if(len(self.blocks) > 0): previous_hash = self.blocks[-1].hash block = Block(len(self.blocks), time.time(), self.current_transactions, previous_hash) block.mine_block(self.difficulty) self.blocks.append(block) self.current_transactions = [] return block def add_block(self, block): self.blocks.append(block) def new_transaction(self, sender, recipient, amount): pem_file = open("public_key.pem", "r") key_data = pem_file.read() pem_file.close() public_key = rsa.PublicKey.load_pkcs1(key_data, 'PEM') pem_file = open("private_key.pem", "r") key_data = pem_file.read() pem_file.close() private_key = rsa.PrivateKey.load_pkcs1(key_data, 'PEM') transaction = Transaction(sender, recipient, amount, time.time()) transaction.sign(private_key, public_key) if transaction.is_valid(): self.current_transactions.append(transaction) return True def generate_keys(self): key = rsa.newkeys(2048) public_key = key[0] private_key = key[1] file_out = open("public_key.pem", "w") file_out.write(public_key.save_pkcs1(format='PEM').decode('UTF-8')) file_out.close() file_out = open("private_key.pem", "w") file_out.write(private_key.save_pkcs1(format='PEM').decode('UTF-8')) file_out.close() @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass def proof_of_work(self, last_proof): # Simple Proof of Work Algorithm pass @staticmethod def valid_proof(last_proof, proof): # Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes? pass @staticmethod def valid_chain(chain): # Determine if a given blockchain is valid pass def resolve_conflicts(self): # Consensus Algorithm: resolves conflicts by replacing our chain with the longest one in the network pass def register_node(self, host, port): self.nodes.append({"host": host, "port": port}) def perform_consensus(self): # Perform consensus algorithm for node in self.nodes: self.connect_with_node(node["host"], node["port"]) def inbounimport unittestimport hashlibimport timeimport jsonimport rsaimport randomfrom p2pnetwork.node import Node class BlockChain(Node): def __init__(self, host='127.0.0.1', port=None): self.blocks = [] self.current_transactions = [] self.blocks = [] self.nodes = [] self.difficulty = 4 #represents the number of zeros that are required to be in the hash if port == None: random.seed() port = random.randint(10000, 20000) super(BlockChain, self).__init__(host, port) self.start() def new_block(self): previous_hash = None if(len(self.blocks) > 0): previous_hash = self.blocks[-1].hash block = Block(len(self.blocks), time.time(), self.current_transactions, previous_hash) block.mine_block(self.difficulty) self.blocks.append(block) self.current_transactions = [] return block def add_block(self, block): self.blocks.append(block) def new_transaction(self, sender, recipient, amount): pem_file = open("public_key.pem", "r") key_data = pem_file.read() pem_file.close() public_key = rsa.PublicKey.load_pkcs1(key_data, 'PEM') pem_file = open("private_key.pem", "r") key_data = pem_file.read() pem_file.close() private_key = rsa.PrivateKey.load_pkcs1(key_data, 'PEM') transaction = Transaction(sender, recipient, amount, time.time()) transaction.sign(private_key, public_key) if transaction.is_valid(): self.current_transactions.append(transaction) return True def generate_keys(self): key = rsa.newkeys(2048) public_key = key[0] private_key = key[1] file_out = open("public_key.pem", "w") file_out.write(public_key.save_pkcs1(format='PEM').decode('UTF-8')) file_out.close() file_out = open("private_key.pem", "w") file_out.write(private_key.save_pkcs1(format='PEM').decode('UTF-8')) file_out.close() @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass def proof_of_work(self, last_proof): # Simple Proof of Work Algorithm pass @staticmethod def valid_proof(last_proof, proof): # Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes? pass @staticmethod def valid_chain(chain): # Determine if a given blockchain is valid pass def resolve_conflicts(self): # Consensus Algorithm: resolves conflicts by replacing our chain with the longest one in the network pass def register_node(self, host, port): self.nodes.append({"host": host, "port": port}) def perform_consensus(self): # Perform consensus algorithm for node in self.nodes: self.connect_with_node(node["host"], node["port"]) def inbounimport unittestimport hashlibimport timeimport jsonimport rsaimport randomfrom p2pnetwork.node import Node class BlockChain(Node): def __init__(self, host='127.0.0.1', port=None): self.blocks = [] self.current_transactions = [] self.blocks = [] self.nodes = [] self.difficulty = 4 #represents the number of zeros that are required to be in the hash if port == None: random.seed() port = random.randint(10000, 20000) super(BlockChain, self).__init__(host, port) self.start() def new_block(self): previous_hash = None if(len(self.blocks) > 0): previous_hash = self.blocks[-1].hash block = Block(len(self.blocks), time.time(), self.current_transactions, previous_hash) block.mine_block(self.difficulty) self.blocks.append(block) self.current_transactions = [] return block def add_block(self, block): self.blocks.append(block) def new_transaction(self, sender, recipient, amount): pem_file = open("public_key.pem", "r") key_data = pem_file.read() pem_file.close() public_key = rsa.PublicKey.load_pkcs1(key_data, 'PEM') pem_file = open("private_key.pem", "r") key_data = pem_file.read() pem_file.close() private_key = rsa.PrivateKey.load_pkcs1(key_data, 'PEM') transaction = Transaction(sender, recipient, amount, time.time()) transaction.sign(private_key, public_key) if transaction.is_valid(): self.current_transactions.append(transaction) return True def generate_keys(self): key = rsa.newkeys(2048) public_key = key[0] private_key = key[1] file_out = open("public_key.pem", "w") file_out.write(public_key.save_pkcs1(format='PEM').decode('UTF-8')) file_out.close() file_out = open("private_key.pem", "w") file_out.write(private_key.save_pkcs1(format='PEM').decode('UTF-8')) file_out.close() @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass def proof_of_work(self, last_proof): # Simple Proof of Work Algorithm pass @staticmethod def valid_proof(last_proof, proof): # Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes? pass @staticmethod def valid_chain(chain): # Determine if a given blockchain is valid pass def resolve_conflicts(self): # Consensus Algorithm: resolves conflicts by replacing our chain with the longest one in the network pass def register_node(self, host, port): self.nodes.append({"host": host, "port": port}) def perform_consensus(self): # Perform consensus algorithm for node in self.nodes: self.connect_with_node(node["host"], node["port"]) def inbounimport unittestimport hashlibimport timeimport jsonimport rsaimport randomfrom p2pnetwork.node import Node class BlockChain(Node): def __init__(self, host='127.0.0.1', port=None): self.blocks = [] self.current_transactions = [] self.blocks = [] self.nodes = [] self.difficulty = 4 #represents the number of zeros that are required to be in the hash if port == None: random.seed() port = random.randint(10000, 20000) super(BlockChain, self).__init__(host, port) self.start() def new_block(self): previous_hash = None if(len(self.blocks) > 0): previous_hash = self.blocks[-1].hash block = Block(len(self.blocks), time.time(), self.current_transactions, previous_hash) block.mine_block(self.difficulty) self.blocks.append(block) self.current_transactions = [] return block def add_block(self, block): self.blocks.append(block) def new_transaction(self, sender, recipient, amount): pem_file = open("public_key.pem", "r") key_data = pem_file.read() pem_file.close() public_key = rsa.PublicKey.load_pkcs1(key_data, 'PEM') pem_file = open("private_key.pem", "r") key_data = pem_file.read() pem_file.close() private_key = rsa.PrivateKey.load_pkcs1(key_data, 'PEM') transaction = Transaction(sender, recipient, amount, time.time()) transaction.sign(private_key, public_key) if transaction.is_valid(): self.current_transactions.append(transaction) return True def generate_keys(self): key = rsa.newkeys(2048) public_key = key[0] private_key = key[1] file_out = open("public_key.pem", "w") file_out.write(public_key.save_pkcs1(format='PEM').decode('UTF-8')) file_out.close() file_out = open("private_key.pem", "w") file_out.write(private_key.save_pkcs1(format='PEM').decode('UTF-8')) file_out.close() @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass def proof_of_work(self, last_proof): # Simple Proof of Work Algorithm pass @staticmethod def valid_proof(last_proof, proof): # Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes? pass @staticmethod def valid_chain(chain): # Determine if a given blockchain is valid pass def resolve_conflicts(self): # Consensus Algorithm: resolves conflicts by replacing our chain with the longest one in the network pass def register_node(self, host, port): self.nodes.append({"host": host, "port": port}) def perform_consensus(self): # Perform consensus algorithm for node in self.nodes: self.connect_with_node(node["host"], node["port"]) def inbounimport unittestimport hashlibimport timeimport jsonimport rsaimport randomfrom p2pnetwork.node import Node class BlockChain(Node): def __init__(self, host='127.0.0.1', port=None): self.blocks = [] self.current_transactions = [] self.blocks = [] self.nodes = [] self.difficulty = 4 #represents the number of zeros that are required to be in the hash if port == None: random.seed() port = random.randint(10000, 20000) super(BlockChain, self).__init__(host, port) self.start() def new_block(self): previous_hash = None if(len(self.blocks) > 0): previous_hash = self.blocks[-1].hash block = Block(len(self.blocks), time.time(), self.current_transactions, previous_hash) block.mine_block(self.difficulty) self.blocks.append(block) self.current_transactions = [] return block def add_block(self, block): self.blocks.append(block) def new_transaction(self, sender, recipient, amount): pem_file = open("public_key.pem", "r") key_data = pem_file.read() pem_file.close() public_key = rsa.PublicKey.load_pkcs1(key_data, 'PEM') pem_file = open("private_key.pem", "r") key_data = pem_file.read() pem_file.close() private_key = rsa.PrivateKey.load_pkcs1(key_data, 'PEM') transaction = Transaction(sender, recipient, amount, time.time()) transaction.sign(private_key, public_key) if transaction.is_valid(): self.current_transactions.append(transaction) return True def generate_keys(self): key = rsa.newkeys(2048) public_key = key[0] private_key = key[1] file_out = open("public_key.pem", "w") file_out.write(public_key.save_pkcs1(format='PEM').decode('UTF-8')) file_out.close() file_out = open("private_key.pem", "w") file_out.write(private_key.save_pkcs1(format='PEM').decode('UTF-8')) file_out.close() @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass def proof_of_work(self, last_proof): # Simple Proof of Work Algorithm pass @staticmethod def valid_proof(last_proof, proof): # Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes? pass @staticmethod def valid_chain(chain): # Determine if a given blockchain is valid pass def resolve_conflicts(self): # Consensus Algorithm: resolves conflicts by replacing our chain with the longest one in the network pass def register_node(self, host, port): self.nodes.append({"host": host, "port": port}) def perform_consensus(self): # Perform consensus algorithm for node in self.nodes: self.connect_with_node(node["host"], node["port"]) def inbounimport unittestimport hashlibimport timeimport jsonimport rsaimport randomfrom p2pnetwork.node import Node class BlockChain(Node): def __init__(self, host='127.0.0.1', port=None): self.blocks = [] self.current_transactions = [] self.blocks = [] self.nodes = [] self.difficulty = 4 #represents the number of zeros that are required to be in the hash if port == None: random.seed() port = random.randint(10000, 20000) super(BlockChain, self).__init__(host, port) self.start() def new_block(self): previous_hash = None if(len(self.blocks) > 0): previous_hash = self.blocks[-1].hash block = Block(len(self.blocks), time.time(), self.current_transactions, previous_hash) block.mine_block(self.difficulty) self.blocks.append(block) self.current_transactions = [] return block def add_block(self, block): self.blocks.append(block) def new_transaction(self, sender, recipient, amount): pem_file = open("public_key.pem", "r") key_data = pem_file.read() pem_file.close() public_key = rsa.PublicKey.load_pkcs1(key_data, 'PEM') pem_file = open("private_key.pem", "r") key_data = pem_file.read() pem_file.close() private_key = rsa.PrivateKey.load_pkcs1(key_data, 'PEM') transaction = Transaction(sender, recipient, amount, time.time()) transaction.sign(private_key, public_key) if transaction.is_valid(): self.current_transactions.append(transaction) return True def generate_keys(self): key = rsa.newkeys(2048) public_key = key[0] private_key = key[1] file_out = open("public_key.pem", "w") file_out.write(public_key.save_pkcs1(format='PEM').decode('UTF-8')) file_out.close() file_out = open("private_key.pem", "w") file_out.write(private_key.save_pkcs1(format='PEM').decode('UTF-8')) file_out.close() @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass def proof_of_work(self, last_proof): # Simple Proof of Work Algorithm pass @staticmethod def valid_proof(last_proof, proof): # Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes? pass @staticmethod def valid_chain(chain): # Determine if a given blockchain is valid pass def resolve_conflicts(self): # Consensus Algorithm: resolves conflicts by replacing our chain with the longest one in the network pass def register_node(self, host, port): self.nodes.append({"host": host, "port": port}) def perform_consensus(self): # Perform consensus algorithm for node in self.nodes: self.connect_with_node(node["host"], node["port"]) def inbounimport unittestimport hashlibimport timeimport jsonimport rsaimport randomfrom p2pnetwork.node import Node class BlockChain(Node): def __init__(self, host='127.0.0.1', port=None): self.blocks = [] self.current_transactions = [] self.blocks = [] self.nodes = [] self.difficulty = 4 #represents the number of zeros that are required to be in the hash if port == None: random.seed() port = random.randint(10000, 20000) super(BlockChain, self).__init__(host, port) self.start() def new_block(self): previous_hash = None if(len(self.blocks) > 0): previous_hash = self.blocks[-1].hash block = Block(len(self.blocks), time.time(), self.current_transactions, previous_hash) block.mine_block(self.difficulty) self.blocks.append(block) self.current_transactions = [] return block def add_block(self, block): self.blocks.append(block) def new_transaction(self, sender, recipient, amount): pem_file = open("public_key.pem", "r") key_data = pem_file.read() pem_file.close() public_key = rsa.PublicKey.load_pkcs1(key_data, 'PEM') pem_file = open("private_key.pem", "r") key_data = pem_file.read() pem_file.close() private_key = rsa.PrivateKey.load_pkcs1(key_data, 'PEM') transaction = Transaction(sender, recipient, amount, time.time()) transaction.sign(private_key, public_key) if transaction.is_valid(): self.current_transactions.append(transaction) return True def generate_keys(self): key = rsa.newkeys(2048) public_key = key[0] private_key = key[1] file_out = open("public_key.pem", "w") file_out.write(public_key.save_pkcs1(format='PEM').decode('UTF-8')) file_out.close() file_out = open("private_key.pem", "w") file_out.write(private_key.save_pkcs1(format='PEM').decode('UTF-8')) file_out.close() @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass def proof_of_work(self, last_proof): # Simple Proof of Work Algorithm pass @staticmethod def valid_proof(last_proof, proof): # Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes? pass @staticmethod def valid_chain(chain): # Determine if a given blockchain is valid pass def resolve_conflicts(self): # Consensus Algorithm: resolves conflicts by replacing our chain with the longest one in the network pass def register_node(self, host, port): self.nodes.append({"host": host, "port": port}) def perform_consensus(self): # Perform consensus algorithm for node in self.nodes: self.connect_with_node(node["host"], node["port"]) def inbounimport unittestimport hashlibimport timeimport jsonimport rsaimport randomfrom p2pnetwork.node import Node class BlockChain(Node): def __init__(self, host='127.0.0.1', port=None): self.blocks = [] self.current_transactions = [] self.blocks = [] self.nodes = [] self.difficulty = 4 #represents the number of zeros that are required to be in the hash if port == None: random.seed() port = random.randint(10000, 20000) super(BlockChain, self).__init__(host, port) self.start() def new_block(self): previous_hash = None if(len(self.blocks) > 0): previous_hash = self.blocks[-1].hash block = Block(len(self.blocks), time.time(), self.current_transactions, previous_hash) block.mine_block(self.difficulty) self.blocks.append(block) self.current_transactions = [] return block def add_block(self, block): self.blocks.append(block) def new_transaction(self, sender, recipient, amount): pem_file = open("public_key.pem", "r") key_data = pem_file.read() pem_file.close() public_key = rsa.PublicKey.load_pkcs1(key_data, 'PEM') pem_file = open("private_key.pem", "r") key_data = pem_file.read() pem_file.close() private_key = rsa.PrivateKey.load_pkcs1(key_data, 'PEM') transaction = Transaction(sender, recipient, amount, time.time()) transaction.sign(private_key, public_key) if transaction.is_valid(): self.current_transactions.append(transaction) return True def generate_keys(self): key = rsa.newkeys(2048) public_key = key[0] private_key = key[1] file_out = open("public_key.pem", "w") file_out.write(public_key.save_pkcs1(format='PEM').decode('UTF-8')) file_out.close() file_out = open("private_key.pem", "w") file_out.write(private_key.save_pkcs1(format='PEM').decode('UTF-8')) file_out.close() @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass def proof_of_work(self, last_proof): # Simple Proof of Work Algorithm pass @staticmethod def valid_proof(last_proof, proof): # Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes? pass @staticmethod def valid_chain(chain): # Determine if a given blockchain is valid pass def resolve_conflicts(self): # Consensus Algorithm: resolves conflicts by replacing our chain with the longest one in the network pass def register_node(self, host, port): self.nodes.append({"host": host, "port": port}) def perform_consensus(self): # Perform consensus algorithm for node in self.nodes: self.connect_with_node(node["host"], node["port"]) def inbounimport unittestimport hashlibimport timeimport jsonimport rsaimport randomfrom p2pnetwork.node import Node class BlockChain(Node): def __init__(self, host='127.0.0.1', port=None): self.blocks = [] self.current_transactions = [] self.blocks = [] self.nodes = [] self.difficulty = 4 #represents the number of zeros that are required to be in the hash if port == None: random.seed() port = random.randint(10000, 20000) super(BlockChain, self).__init__(host, port) self.start() def new_block(self): previous_hash = None if(len(self.blocks) > 0): previous_hash = self.blocks[-1].hash block = Block(len(self.blocks), time.time(), self.current_transactions, previous_hash) block.mine_block(self.difficulty) self.blocks.append(block) self.current_transactions = [] return block def add_block(self, block): self.blocks.append(block) def new_transaction(self, sender, recipient, amount): pem_file = open("public_key.pem", "r") key_data = pem_file.read() pem_file.close() public_key = rsa.PublicKey.load_pkcs1(key_data, 'PEM') pem_file = open("private_key.pem", "r") key_data = pem_file.read() pem_file.close() private_key = rsa.PrivateKey.load_pkcs1(key_data, 'PEM') transaction = Transaction(sender, recipient, amount, time.time()) transaction.sign(private_key, public_key) if transaction.is_valid(): self.current_transactions.append(transaction) return True def generate_keys(self): key = rsa.newkeys(2048) public_key = key[0] private_key = key[1] file_out = open("public_key.pem", "w") file_out.write(public_key.save_pkcs1(format='PEM').decode('UTF-8')) file_out.close() file_out = open("private_key.pem", "w") file_out.write(private_key.save_pkcs1(format='PEM').decode('UTF-8')) file_out.close() @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass def proof_of_work(self, last_proof): # Simple Proof of Work Algorithm pass @staticmethod def valid_proof(last_proof, proof): # Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes? pass @staticmethod def valid_chain(chain): # Determine if a given blockchain is valid pass def resolve_conflicts(self): # Consensus Algorithm: resolves conflicts by replacing our chain with the longest one in the network pass def register_node(self, host, port): self.nodes.append({"host": host, "port": port}) def perform_consensus(self): # Perform consensus algorithm for node in self.nodes: self.connect_with_node(node["host"], node["port"]) def inbounimport unittestimport hashlibimport timeimport jsonimport rsaimport randomfrom p2pnetwork.node import Node class BlockChain(Node): def __init__(self, host='127.0.0.1', port=None): self.blocks = [] self.current_transactions = [] self.blocks = [] self.nodes = [] self.difficulty = 4 #represents the number of zeros that are required to be in the hash if port == None: random.seed() port = random.randint(10000, 20000) super(BlockChain, self).__init__(host, port) self.start() def new_block(self): previous_hash = None if(len(self.blocks) > 0): previous_hash = self.blocks[-1].hash block = Block(len(self.blocks), time.time(), self.current_transactions, previous_hash) block.mine_block(self.difficulty) self.blocks.append(block) self.current_transactions = [] return block def add_block(self, block): self.blocks.append(block) def new_transaction(self, sender, recipient, amount): pem_file = open("public_key.pem", "r") key_data = pem_file.read() pem_file.close() public_key = rsa.PublicKey.load_pkcs1(key_data, 'PEM') pem_file = open("private_key.pem", "r") key_data = pem_file.read() pem_file.close() private_key = rsa.PrivateKey.load_pkcs1(key_data, 'PEM') transaction = Transaction(sender, recipient, amount, time.time()) transaction.sign(private_key, public_key) if transaction.is_valid(): self.current_transactions.append(transaction) return True def generate_keys(self): key = rsa.newkeys(2048) public_key = key[0] private_key = key[1] file_out = open("public_key.pem", "w") file_out.write(public_key.save_pkcs1(format='PEM').decode('UTF-8')) file_out.close() file_out = open("private_key.pem", "w") file_out.write(private_key.save_pkcs1(format='PEM').decode('UTF-8')) file_out.close() @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass def proof_of_work(self, last_proof): # Simple Proof of Work Algorithm pass @staticmethod def valid_proof(last_proof, proof): # Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes? pass @staticmethod def valid_chain(chain): # Determine if a given blockchain is valid pass def resolve_conflicts(self): # Consensus Algorithm: resolves conflicts by replacing our chain with the longest one in the network pass def register_node(self, host, port): self.nodes.append({"host": host, "port": port}) def perform_consensus(self): # Perform consensus algorithm for node in self.nodes: self.connect_with_node(node["host"], node["port"]) def inbounimport unittestimport hashlibimport timeimport jsonimport rsaimport randomfrom p2pnetwork.node import Node class BlockChain(Node): def __init__(self, host='127.0.0.1', port=None): self.blocks = [] self.current_transactions = [] self.blocks = [] self.nodes = [] self.difficulty = 4 #represents the number of zeros that are required to be in the hash if port == None: random.seed() port = random.randint(10000, 20000) super(BlockChain, self).__init__(host, port) self.start() def new_block(self): previous_hash = None if(len(self.blocks) > 0): previous_hash = self.blocks[-1].hash block = Block(len(self.blocks), time.time(), self.current_transactions, previous_hash) block.mine_block(self.difficulty) self.blocks.append(block) self.current_transactions = [] return block def add_block(self, block): self.blocks.append(block) def new_transaction(self, sender, recipient, amount): pem_file = open("public_key.pem", "r") key_data = pem_file.read() pem_file.close() public_key = rsa.PublicKey.load_pkcs1(key_data, 'PEM') pem_file = open("private_key.pem", "r") key_data = pem_file.read() pem_file.close() private_key = rsa.PrivateKey.load_pkcs1(key_data, 'PEM') transaction = Transaction(sender, recipient, amount, time.time()) transaction.sign(private_key, public_key) if transaction.is_valid(): self.current_transactions.append(transaction) return True def generate_keys(self): key = rsa.newkeys(2048) public_key = key[0] private_key = key[1] file_out = open("public_key.pem", "w") file_out.write(public_key.save_pkcs1(format='PEM').decode('UTF-8')) file_out.close() file_out = open("private_key.pem", "w") file_out.write(private_key.save_pkcs1(format='PEM').decode('UTF-8')) file_out.close() @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass def proof_of_work(self, last_proof): # Simple Proof of Work Algorithm pass @staticmethod def valid_proof(last_proof, proof): # Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes? pass @staticmethod def valid_chain(chain): # Determine if a given blockchain is valid pass def resolve_conflicts(self): # Consensus Algorithm: resolves conflicts by replacing our chain with the longest one in the network pass def register_node(self, host, port): self.nodes.append({"host": host, "port": port}) def perform_consensus(self): # Perform consensus algorithm for node in self.nodes: self.connect_with_node(node["host"], node["port"]) def inbounnode["port"]) def inboun
